using Microsoft.CodeAnalysis;

namespace Bedrock.BuildingBlocks.Testing.Architecture;

/// <summary>
/// Classe base abstrata para regras de arquitetura.
/// Implementa o padrão Template Method: <see cref="Analyze"/> itera os projetos,
/// extrai os tipos próprios, pré-computa contexto global (tipos herdados)
/// e chama <see cref="AnalyzeType"/> para cada tipo elegível.
/// </summary>
public abstract class Rule
{
    /// <summary>
    /// Nome identificador da regra (ex: DE001_SealedClass).
    /// </summary>
    public abstract string Name { get; }

    /// <summary>
    /// Descrição da regra.
    /// </summary>
    public abstract string Description { get; }

    /// <summary>
    /// Severidade padrão das violações geradas por esta regra.
    /// </summary>
    public abstract Severity DefaultSeverity { get; }

    /// <summary>
    /// Caminho relativo para a ADR relacionada.
    /// </summary>
    public abstract string AdrPath { get; }

    /// <summary>
    /// Analisa as compilações e retorna os resultados detalhados por projeto.
    /// Para cada projeto, extrai os tipos próprios (filtrando gerados),
    /// pré-computa o set global de tipos herdados e chama <see cref="AnalyzeType"/>
    /// para cada tipo elegível, capturando tanto sucessos quanto falhas.
    /// </summary>
    /// <param name="compilations">Compilações dos projetos a serem analisados.</param>
    /// <param name="rootDir">Diretório raiz do repositório.</param>
    /// <returns>Lista de resultados por projeto, contendo o status de cada tipo analisado.</returns>
    public IReadOnlyList<RuleAnalysisResult> Analyze(
        IReadOnlyDictionary<string, Compilation> compilations,
        string rootDir)
    {
        var results = new List<RuleAnalysisResult>();

        // Pré-computar contexto global: tipos herdados (Roslyn + grep fallback)
        var globalInheritedTypes = BuildGlobalInheritedTypes(compilations, rootDir);

        foreach (var (projectName, compilation) in compilations)
        {
            var typeResults = new List<TypeAnalysisResult>();
            var assemblySymbol = compilation.Assembly;
            var allTypes = GetAllNamedTypes(compilation.GlobalNamespace);

            var ownTypes = allTypes
                .Where(t => SymbolEqualityComparer.Default.Equals(t.ContainingAssembly, assemblySymbol))
                .ToList();

            foreach (var type in ownTypes)
            {
                // Ignorar tipos sem localização no source (tipos gerados)
                var location = type.Locations.FirstOrDefault(l => l.IsInSource);
                if (location is null)
                    continue;

                // Ignorar classes parciais geradas pelo compilador (ex: Program)
                if (IsAutoGeneratedOrPartialProgram(type, location))
                    continue;

                var filePath = location.GetLineSpan().Path;
                var relativePath = GetRelativePath(filePath, rootDir);
                var lineNumber = location.GetLineSpan().StartLinePosition.Line + 1;

                var context = new TypeContext
                {
                    ProjectName = projectName,
                    Compilation = compilation,
                    Type = type,
                    Location = location,
                    RelativeFilePath = relativePath,
                    LineNumber = lineNumber,
                    RootDir = rootDir,
                    GlobalInheritedTypes = globalInheritedTypes
                };

                // Verificar supressão via comentário: // ArchRule disable <RuleName> : razão
                if (IsTypeSuppressed(location, Name))
                    continue;

                var violation = AnalyzeType(context);

                typeResults.Add(new TypeAnalysisResult
                {
                    TypeName = type.Name,
                    TypeFullName = type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
                    File = relativePath,
                    Line = lineNumber,
                    Status = violation is null ? TypeAnalysisStatus.Passed : TypeAnalysisStatus.Failed,
                    Violation = violation
                });
            }

            results.Add(new RuleAnalysisResult
            {
                RuleName = Name,
                RuleDescription = Description,
                DefaultSeverity = DefaultSeverity,
                AdrPath = AdrPath,
                ProjectName = projectName,
                TypeResults = typeResults
            });
        }

        return results;
    }

    /// <summary>
    /// Analisa um tipo individual e retorna uma violação se aplicável, ou null se o tipo está ok.
    /// </summary>
    /// <param name="context">Contexto com todas as informações do tipo sendo analisado.</param>
    /// <returns>Uma violação se o tipo viola a regra, ou null.</returns>
    protected abstract Violation? AnalyzeType(TypeContext context);

    #region Contexto global

    /// <summary>
    /// Constrói o set global de tipos herdados a partir das compilações Roslyn
    /// e do fallback por grep no código-fonte.
    /// </summary>
    private static HashSet<string> BuildGlobalInheritedTypes(
        IReadOnlyDictionary<string, Compilation> compilations,
        string rootDir)
    {
        var inherited = new HashSet<string>();

        // Via Roslyn: fully qualified names dos base types
        foreach (var (_, compilation) in compilations)
        {
            var allTypes = GetAllNamedTypes(compilation.GlobalNamespace);
            foreach (var type in allTypes)
            {
                if (type.BaseType is not null)
                {
                    var baseFullName = type.BaseType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    inherited.Add(baseFullName);
                }
            }
        }

        // Fallback: grep no source para projetos que o workspace não conseguiu compilar
        var sourceInherited = FindInheritanceInSourceFiles(rootDir);
        foreach (var typeName in sourceInherited)
            inherited.Add(typeName);

        return inherited;
    }

    #endregion

    #region Helpers estáticos (disponíveis para as regras filhas)

    /// <summary>
    /// Coleta recursivamente todos os tipos nomeados de um namespace.
    /// </summary>
    protected static List<INamedTypeSymbol> GetAllNamedTypes(INamespaceSymbol namespaceSymbol)
    {
        var types = new List<INamedTypeSymbol>();

        foreach (var member in namespaceSymbol.GetMembers())
        {
            if (member is INamedTypeSymbol namedType)
            {
                types.Add(namedType);
                types.AddRange(GetNestedTypes(namedType));
            }
            else if (member is INamespaceSymbol childNamespace)
            {
                types.AddRange(GetAllNamedTypes(childNamespace));
            }
        }

        return types;
    }

    /// <summary>
    /// Coleta tipos nested recursivamente.
    /// </summary>
    protected static IEnumerable<INamedTypeSymbol> GetNestedTypes(INamedTypeSymbol type)
    {
        foreach (var member in type.GetTypeMembers())
        {
            yield return member;
            foreach (var nested in GetNestedTypes(member))
                yield return nested;
        }
    }

    /// <summary>
    /// Busca herança no código-fonte via análise textual, como fallback para projetos
    /// que o MSBuildWorkspace não conseguiu compilar (ex: templates com referências relativas).
    /// </summary>
    private static HashSet<string> FindInheritanceInSourceFiles(string rootDir)
    {
        var inheritedTypeNames = new HashSet<string>();
        var srcDir = Path.Combine(rootDir, "src");

        if (!Directory.Exists(srcDir))
            return inheritedTypeNames;

        foreach (var csFile in Directory.GetFiles(srcDir, "*.cs", SearchOption.AllDirectories))
        {
            // Ignorar arquivos em obj/
            if (csFile.Contains(Path.DirectorySeparatorChar + "obj" + Path.DirectorySeparatorChar,
                    StringComparison.OrdinalIgnoreCase))
                continue;

            try
            {
                foreach (var line in File.ReadLines(csFile))
                {
                    var trimmed = line.TrimStart();
                    if (!trimmed.Contains("class ", StringComparison.Ordinal))
                        continue;

                    var colonIndex = trimmed.IndexOf(':');
                    if (colonIndex < 0)
                        continue;

                    var afterColon = trimmed[(colonIndex + 1)..].Trim();
                    var baseParts = afterColon.Split([',', '{', ' '], StringSplitOptions.RemoveEmptyEntries);
                    if (baseParts.Length > 0)
                    {
                        var baseName = baseParts[0].Trim();
                        var genericIndex = baseName.IndexOf('<');
                        if (genericIndex > 0)
                            baseName = baseName[..genericIndex];

                        inheritedTypeNames.Add(baseName);
                    }
                }
            }
            catch
            {
                // Ignorar arquivos que não podem ser lidos
            }
        }

        return inheritedTypeNames;
    }

    /// <summary>
    /// Verifica se o tipo está suprimido para esta regra via comentário na(s) linha(s) acima
    /// da declaração do tipo. Formato: <c>// ArchRule disable RuleName : razão</c>.
    /// </summary>
    private static bool IsTypeSuppressed(Location location, string ruleName)
    {
        var lineSpan = location.GetLineSpan();
        var typeLine = lineSpan.StartLinePosition.Line;

        if (typeLine < 1)
            return false;

        var sourceText = location.SourceTree?.GetText();
        if (sourceText is null)
            return false;

        // Procurar nas 5 linhas anteriores à declaração do tipo (para acomodar
        // atributos, summary XML e outros comentários entre a anotação e o tipo)
        var startLine = Math.Max(0, typeLine - 5);
        for (var i = typeLine - 1; i >= startLine; i--)
        {
            var line = sourceText.Lines[i];
            var lineText = sourceText.ToString(line.Span).Trim();

            // Parar se encontrar uma declaração de tipo ou membro (não é mais contexto do nosso tipo)
            if (lineText.Length > 0 && !lineText.StartsWith("//", StringComparison.Ordinal) &&
                !lineText.StartsWith("/*", StringComparison.Ordinal) &&
                !lineText.StartsWith("*", StringComparison.Ordinal) &&
                !lineText.StartsWith("[", StringComparison.Ordinal) &&
                !lineText.StartsWith("/// ", StringComparison.Ordinal) &&
                !lineText.StartsWith("}", StringComparison.Ordinal) &&
                lineText.Length > 0)
                break;

            if (lineText.Contains($"ArchRule disable {ruleName}", StringComparison.OrdinalIgnoreCase))
                return true;
        }

        return false;
    }

    private static bool IsAutoGeneratedOrPartialProgram(INamedTypeSymbol type, Location location)
    {
        if (type.Name is "<Program>$" or "Program")
            return true;

        var filePath = location.GetLineSpan().Path;
        if (string.IsNullOrEmpty(filePath))
            return true;

        return filePath.Contains("obj", StringComparison.OrdinalIgnoreCase) ||
               filePath.Contains(".g.cs", StringComparison.OrdinalIgnoreCase) ||
               filePath.Contains(".generated.cs", StringComparison.OrdinalIgnoreCase);
    }

    /// <summary>
    /// Obtém o caminho relativo de um arquivo em relação ao rootDir.
    /// </summary>
    protected static string GetRelativePath(string fullPath, string rootDir)
    {
        if (string.IsNullOrEmpty(fullPath) || string.IsNullOrEmpty(rootDir))
            return fullPath;

        try
        {
            return Path.GetRelativePath(rootDir, fullPath).Replace('\\', '/');
        }
        catch
        {
            return fullPath;
        }
    }

    #endregion
}
